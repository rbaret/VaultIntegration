# Vault deployment and integration

## Challenge
### Goal

Protect secrets needed by infrastructure services and applications (e.g. database credentials). Hashicorp
Vault is a secrets manager that can safely store such information and even inject it into other services.

### Requirements

- deploy a Vault instance;
- store some credentials; and
- inject them into another service.

### Constraints:

- Provide documentation for your work
- Justify your choices.
- Make your setup reproducible

### Steps 
#### Choose a deployment target: Kubernetes, Docker, VM etc.

- What are its advantages for this exercise?
- Set up a local environment if necessary.
- Provide: A list or script with all commands used, if any.

#### Choose a service to inject the secrets to: Redis etc.

- What are the benefits/shortcomings of your service’s security parameter?

#### Run a Vault instance
- Provide: The deployment scripts, manifests or similar.

#### Generate some credentials and store them in Vault
- Provide: A list or script with all commands used.

#### Inject these credentials into the service you chose
- Can you make the credentials updateable in Vault?
- Provide: The deployment scripts, manifests or similar.

#### Test your setup
- Provide: A list or script with all commands used.

#### Bonus Use the PKI engine
- Add TLS to your service.
- Inject certificates and keys from the Vault PKI engine.
- Provide: A list or script with all commands used.

### Deliverables

Archive everything : packaging, documentation.
Describe the tools used.
Testing scripts + additional validation if necessary.

## Solution

### Deployment target

I chose to deploy this solution via Docker and docker-compose. The advantages of this approach are:
- It is quite easy to deploy a simple set of containers for development purposes
- The prerequisites are quite simple for anyone to redeploy the env: Docker and docker-compose
- For dev purpose, it's easy to find images for the services I need
I chose docker-compose to gather docker containers in a single environment. I can also interact with the containers via a shell script and run commands on them using the docker exec command.

You can find the docker-compose file in the root of this repo.

### Service to inject the secrets to

I chose to deploy a simple LAMP install with a dummy application. This is an environment I know well-enough to debug it.
I deploy a base Apache/PHP image as well as the base mysql image from official repos.
I fill the DB with some dummy records as well and create a simple php page to connect to this database and display the records.
To pass the Vault token to the app, I inject it via an environment variable. This is not the safest way but this is not the point.


### Run a Vault instance

Vault will be run in dev mode as it is more than enough for our purposes. The quickest way to deploy it is simply to use the docker image provided by Hashicorp. 
Therefore, it is still a good thing to try to implement some basic security measures to protect the secrets. For example, we will not store any secret in the code as they might be published by mistake. Instead, we will generate a random root token and pass it as an environment variable to the container.


### Deployment scripts

The ```run.sh``` script will deploy the environment thanks to docker-compose and the ```docker-compose.yaml``` file attached, and configure Vault to generate dynamic credentials for the app to connect to the database.

The ```dump.sql``` creates a table and inserts some dummy records in the database, and is called in the deployment script via docker exec commands on the database container

The ```app``` folder contains the small php app and is mounted into the apache/php container as the document root.


### Testing the app 

Browse the app on the docker host on port 80, e.g : http://dockervm:80
The web page displays the credentials used by the app and shows the records fetched from the database.
Every refresh triggers a new set of credentials to be generated by Vault, as well as a record to be added using a different credential with a different policy

The credentials are fetched through an API call to the vault using curl and the token passed as a header. The credentials are then used to connect to the database and fetch or insert the records, depending on the credential.


### Vault credentials
I have chosen to go with dynamic credentials with a short TTL, which removes the need to rotate the credentials and to update them. The credentials are generated by Vault and are valid for 1 minute (arbitrary duration for this test). The app will fetch new credentials every time it is refreshed.

Therefore if I had gone with more "static" secrets, e.g : a fixed username, I would have probably used the KV secrets engine to store the credentials and the app would have fetched them from there. I would have then used the API to update the credentials in the KV store, and dealt with a credentials rotation.

### TLS with PKI engine
I did not have time to fiddle with the PKI included in Vault. 
If I had had the time I would have built a self-signed CA in Vault for dev purpose and created a role and a policy to be able to retrieve a new certificate every time the app container is redeployed. I would then have stored the various values in the corresponding files (cacert, private key and certificate) and created a config file for apache to use them from the mounted volume.

It would be a good thing to enable https for the vault as well, as you don´t want the secrets to transit in plain text.

### Conclusion

ALthough I had to learn how to use Vault, it is similar to keyvaults in Azure for example and I was able to deploy a working environment in a few hours (the debugging of the environment itself was probably the hardest part, as I had not dealt with Docker for a long time). I did not have the time to implement the PKI engine but I think I have covered the main points of the exercise.

This setup is fairly basic as it is made for a portable dev environment and in the absence of any portable way of authentication.

In a production environment, I would have used authentication and service accounts to perform the token retrieval for example, instead of having the tokens in plain text visible in various places (ps is a verbose command when starting containers with env variables...).

I did not go with Redis as I have never used it and I wanted to focus on the Vault part (which I want to implement in my personal projects anyway, so I saw it as a good opportunity to learn it), but I understand how credentials could be used to query it.

## References

### Tools used
- Docker
- Docker-compose
- Vault, mysql and php/apache docker images
- curl
- jq
- bash
- VSCode for the development/documentation
- Adminer for the database management and troubleshooting
- Vault documentation
- Docker documentation
- Google, Stackoverflow, Copilot for boilerplate code

### Train of thoughts:
- I need to pass the root token to the vault container : Randomly generate it and pass it as an environment variable
- I neeed to create a random password for the root user of the database : Randomly generate it and pass it as an environment variable. Therefore it will be an issue after each run of the shell script which creates the environment if mysql volume is still present (mysql wont be reinitialized and the root password will be different)
- I need to create a DB user with permissions to create other users, this user will be used by Vault to generate dynamic credentials : SQL statement through docker exec
- I neeed to configure Vault to connect to the DB and be able to generate dynamic credentials : enable database secrets engine and configure it using the user created above 
- I need to create a Vault policy to allow the app to fetch the secrets : 2 policies, 1 for read-only, 1 for read-write
- I need to create a Vault role to map the policy to the secrets engine : create a role with proper CREATE and GRANT statements to generate a user with a limited duration, and assign it the corresponding SQL role
- I need to create a Vault token with the policies : create a token with the 2 policies attached, and pass it as an environment variable to the app
- I need to configure the app to fetch the secrets from Vault and use them to connect to the database : use the token and query Vault to get the credentials, then use them to connect to the database.

## How to reproduce

### Prerequisites

Required software :
- Docker
- docker-compose
- curl
- jq
- bash
- git (only if cloning the repo)

Network :
- The docker host needs to have its ports 80,443 (optional, I did not have time to implement TLS for Apache),8200 and 3306 (optional, only internal communications between containers) available for the containers to bind to them (or change the ports in the docker-compose file, the SQL port does not need to be exposed to the host for example)

### Steps

- Clone the repo or download the files
- Run the ```run.sh``` script to deploy the environment on the docker machine.
- Wait for the script to finish, it will take a few seconds to start the containers and configure Vault
- Browse the app on the docker host on port 80, e.g : http://dockervm:80
- The web page displays the credentials used by the app and shows the records fetched from the database.
- Refresh the web page to trigger a new set of credentials to be generated by Vault, as well as a record to be added using a different credential with a different policy
